# Java cheatsheet

<br>
<br>

## Topic 1: Hello world

<br>

### `Print Line`
<br>

`System.out.println()` can print to the console:
  - `System` is a class from the core library provided by Java.
  - `out` is an object that controls the output.
  - `println()` is a method associated with that object that receives a single argument.

~~~
System.out.println("Hello, world!");
// output: Hello, World! 
~~~

<br>

### `Comments`
<br>

Comments are bits of text that are ignored by the compiler. They are used to increase the readability of a program.
  - Single line comments are created by using //.
  - Multi-line comments are created by starting with /* and ending with */.

~~~
// I am a single comment

/*
And i am a 
multi-line comment.
*/
~~~

<br>

### `main Method`
<br>

In Java, every application must contain a `main()` method, which is the entry point for the application. All other methods are invoked from the `main()` method.

The signature of the method is `public static void main(String args[]){}`. It accepts a single argument: an array of elements of type `String`

~~~
public class Person{
  public static void main(String[] args){
    System.out.println("Hello, world!");
  }
} 
~~~
<br>

### `Classes`
<br>

A `class` represents a single concept.

A Java program must have one class whose name is the same as the program filename.

In the example, the `Person` class must be declared in a program file named `Person.java`.

~~~ 
public class Person{
  public static void main(String[] args){
    System.out.println("I am a person, not a computer.");
  }
}
~~~ 

<br>

### `Compiling Java`
<br>

In Java, when we compile a program, each individual class is converted into a `.class` file, which is known as byte code.

The JVM (Java virtual machine) is used to run the byte code.

~~~
# Compile the class file:
javac hello.java

# Execute the compiled file:
java hello
~~~

<br>

###  `Whitespace`
<br>

Whitespace, including spaces and newlines, between statements is ignored.

~~~
System.out.println("Example of a statement");

System.out.println("Another statement");

// Output:
// Example of a statement
// Another statement
~~~

<br>

### `Statements`
<br>

In Java, a statement is a line of code that executes a task and is terminated with a `;`.

~~~
System.out.println("Java Programming"); 
~~~

<br>
<hr>
<br>

## Topic 2: Variables
<br>

### `boolean Data Type`
<br>

In Java, the `boolean` primitive data type is used to store a value, which can be either `true` or `false`.

~~~ 
boolean result = true;
boolean isMarried = false;
~~~ 
<br>

### `Strings`
<br>

A String in Java is a Object that holds multiple characters. It is not a primitive datatype.

A String can be created by playcing characters between a pair of double quotes (`"`);

To compare Strings, the `equals()` method must be used instead of the primitive equality comparator `==`;

~~~
// Creating a String variable
String name = "Bob";

// The following will print "false" because strings are case-sensitive
System.out.println(name.equals("bob"));
~~~

<br>

### `int Data Type`
<br>

In Java, the `int` datatype is used to store integer values. This means that it can store all positive and negative whole numbers and zero.

~~~
int num1 = 10;    // positive value
int num2 = -5;    // negative value
int num3 = 0;     // zero value
int num4 = 12.5;  // not allowed
~~~

<br>

### `char Data Type`
<br>

In Java, `char` is used to store a single character. The character must be enclosed in single quotes.

~~~ 
char answer = 'y';
~~~ 
<br>

### `Primitive Data Types`
<br>

Java's most basic data types are known as `primitive data types` and are in the system by default.

The available types are as follows:

- `int`
- `char`
- `boolean`
- `byte`
- `long`
- `short`
- `double`
- `float`

`null` is another, but it can only ever store the value `null`.

~~~
int age = 28;

char grade = 'A';

boolean late = true;

byte b = 20;

long num1 = 1234567;

short no = 10;

float k = (float)12.5;  // ou  float k = 12.5f;

double pi = 3.14;
~~~

<br>

### `Static Typing`
<br>

In Java, the type of a variable is checked at compile time. This is known as `static typing`. It has the advantage of catching the errors at compile time rather than at execution time.

Variables must be declared with the appropriate data type or the program will not compile.

~~~
int i = 10;       // type is int
char ch = 'a';    // type is char

j = 20;           // won't compile no type is given
char name = "lil";// won't compile, wrong datatype
~~~

<br>

### `final Keyword`
<br>

The value of a variable cannot be changed if the variable was declared using the `final` keyword.

Note that the variable must be given a value when it is declared as `final`. `final` variables cannot be changed; any attempts at doing so will result in an error message.

~~~
// Value cannot be changed;
final double PI = 3.14;
~~~
<br>

### `double Data Type`
<br>

The `double` primitive data type is used to hold decimal values.

~~~
double PI = 3.14;
double price = 5.75; 
~~~

<br>

###  `Math Operations`
<br>

Basic math operations can be applied to `int`, `double` and `float` data types:

- `+` addition
- `-` subtraction
- `*` multiplicaiton
- `/` division
- `%` modulo (yields the remainder)

These operations are not supported for other data types.

~~~
int a = 20;
int b = 10;

int result;

result = a + b;      // 30
result = a - b;      // 10
result = a * b;      // 200
result = a / b;      // 2
result = a % b;      // 0
~~~

<br>

###  `Comparison Operators`
<br>

Comparison operators can be used to compare two values:

- `>` greater than
- `<` less than
- `>=` greater than or equal to
- `<=` less than or equal to
- `==` equal to
- `!=` not equal to

They are supported for primitive data types and the result of a comparison is a boolean value `true` or `false`.

~~~
int a = 5;
int b = 3;

boolean result = a > b;
// result now holds the boolean value true
~~~

<br>

### `Compound Assignment Operators`
<br>

Compound assignment operators can be used to change and reassign the value of a variable using one line of code. Compound assignment operators include `+=`, `-=`, `*=`, `/=`, and `%=`.

~~~
int number = 5;

number += 3;      // Value is now 8
number -= 4;      // Value is now 4
number *= 6;      // Value is now 24
number /= 2;      // Value is now 12
number %= 7;      // Value is now 5
~~~ 

<br>

### `Increment and Decrement Operators`
<br>

The increment operator, (`++`), can increase the value of a number-based variable by `1` while the decrement operator, (`--`), can decrease the value of a variable by `1`.

~~~
int numApples = 5;
numApples++;    // Value is now 6

int numOranges = 5;
numOranges--;   // Value is now 4
~~~

<br>

### `Order of Operations`
<br>

The order in which an expression with multiple operators is evaluated is determined by the order of operations: parentheses -> multiplication -> division -> modulo -> addition -> subtraction.

<br>
<hr>
<br>

## Topic 3: Object-Oriented Java

<br>

### `Java object's state and behavior`
<br>

In Java, instances of a class are known as objects. Every object has state and behavior in the form of instance fields and methods respectively.

~~~
public class Person {
  // state of an object
  int age;
  String name;

  // behavior of an object
  public void set_value(){
    age = 20;
    name = "Robin";
  }
  public void get_value(){
    System.out.println("Age is " + age);
    System.out.println("Name is " + name);
  }

  // main method
  public static void main(String[] args){
    // creates a new Person object
    Person p = new Person();

    // changes state through behavior
    p.set_value();
  }
}
~~~

<br>

### `Java instance`
<br>

Java instances are objects that are based on classes. For example, `Bob` may be an instance of the class `Person`.

Every instance has access to its own set of variables which are known as `instance fields`, which are variables declared within the scope of the instance. Values for instance fields are assigned within the constructor method.

~~~
public class Person{
  int age;
  String name;

  // Constructor method
  public Person(int age, String name){
    this.age = age;
    this.name = name;
  }

  public static void main(String[] args){
    Person Bob = new Person(31, "Bob");
    Person Alice = new Person(27, "Alice");
  }
} 
~~~

<br>

### `Java dot notation`
<br>

In Java programming language, we use `.` to access the variables and methods of an object or a Class.

This is known as `dot notation` and the structure looks like this - `instanceOrClassName.fieldOrMethodName`

~~~
public class Person {
  int age;

  public static void main(String[] args){
    Person p = new Person();

    // here we use dot notation to set age
    p.age = 20;

    // here we use dot notation to access age and print
    System.out.println("Age is " + p.age);
    // Output: Age is 20
  }
}
~~~

<br>

### `Constructor Method in Java`
<br>

Java classes contain a `constructor` method which is used to create instances of the class.

The constructor is named after the class. If no constructor is defined, a default empty constructor is used.

~~~
public class Maths {
  public Maths(){
    System.out.println("I am constructor");
  }
  public static void main(String[] args){
    System.out.println("I am main");
    Maths obj1 = new Maths();
  }
}
~~~

<br>

### `Creating a new Class instance in Java`
<br>

In Java, we use the `new` keyword followed by a call to the class constructor in order to create a new `instance` of a class.

The constructor can be used to provide initial values to instance fields.

~~~
public class Person{
  int age;
  public class Person(int a){
    age = a;
  }

  public static void main(String[] args){
    // Here, we create a new instance of the Person class:
    Person p = new Person(20);
    System.out.println("Age is " + p.age);
  }
}
~~~

<br>

### `Reference Data Types`
<br>

A variable with a reference data type has a value that references the memory address of an instance. During variable declaration, the class name is used as the variable's type.

~~~ 
public class Cat{
  public Cat(){
    // instructions for creating a cat instance
  }

  public static void main(String[] args){
    // garfield is declared with reference data type 'Cat'
    Cat garfield = new Cat();
    System.out.println(garfield); // Prints: Cat@76ed65528
  }
}
~~~ 

<br>

### `Constructor Signatures`
<br>

A class can contain multiple constructors as long as they have different parameter values. A signature helps the compiler differentiate between the different constructors.

A signature is made up of the constructor's name and a list of its parameters.

~~~ 
// The signature is `Cat(String furLength, boolean hasClaws)`.
public class cat{
  String furType;
  boolean containsClaws;

  public Cat(String furLength, boolean hasClaws){
    furType = furLength;
    containsClaws = hasClaws;
  }

  public static void main(String[] args){
    Cat garfield = new Cat("Long-hair", true);
  }
}
~~~ 

<br>

###  `null Values`
<br>

`null` is a special value that denotes that an object has void reference.

~~~
public class Bear{
  String species;
  
  public Bear(String speciesOfBear){
    species = speciesOfBear;
  }

  public static void main(String[] args){
    Bear baloo = new Bear("Sloth bear");
    System.out.println(baloo); // Prints: Bear@4517d9a3
    // set object to null
    baloo = null;
    System.out.println(baloo); // Prints: null
  }
} 
~~~

<br>

### `The body of a Java Method`
<br>

In Java, we use curly brackets `{}` to enclose the body of a method.

The statements written inside the `{}` are executed when a method is called.

~~~ 
public class Maths{
  
  public static void sum(int a, int b){ // start of sum
    int result = a + b;
    System.out.println("Sum is " + result);
  } // End of sum

  public static void main(String[] args){
    // Here, we call the sum method
    sum(10,20);
    // Output: Sum is 30
  }

}
~~~ 

<br>

### `Method parameters in Java`
<br>

In Java,parameters are declared in a method definition. The parameters act as variavles inside the method and hold the value that was passed in. They can be used inside a method for printing or calculation purposes.

In the example, a and b are two parameters which, when the method is called, hold the value 10 and 20 respectively.

~~~ 
public class Maths{
  
  public int sum(int a, int b){
    int k = a + b;
    return k;
  }

  public static void main(String[] args){
    Maths m = new Maths();
    int result = m.sum(10,20);
    System.out.println("sum is " + result);
    // prints - sum is 30
  }
}
~~~

<br>

### `Java Variables Inside a Method`
<br>

Java variables defined inside a method cannot be used outside the scope of that method.

~~~
// For example, `i` and `j` variables are available in the `main` method only:
public class Maths{
  public static void main(String args[]){
    int i, j;
    System.out.println("These two variables are available in main method only");
  }
} 
~~~

<br>

### `Returning info from a Java method`
<br>

A Java method can return any value that can be saved in a variable. The value returned must match with the return type specified in the method signature.

The value is returned using the `return` keyword.

~~~
public class Maths{

  // return type is int
  public int sum(int a, int b){
    int k;
    k = a + b;

    // sum is returned using the return keyword
    return k;
  }

  public static void main(String[] args){
    Maths m = new Maths();
    int result;
    result = m.sum(10,20);
    System.out.println("Sum is " + result);
    // Output: sum is 30
  }
} 
~~~

<br>

### `Declaring a Method`
<br>

Method declarations should define the following method information:

- `scope` (private or public)
- `return type`
- `method name`
- `any parameters it receives`

~~~
// Here is a public method named sum whose return type is int and has two int parameters a and b

public int sum(int a, int b){
  return(a + b);
}
~~~

<br>
<hr>
<br>

## Topic 3: Conditionals and Control Flow
<br>

### `else Statement`
<br>

The `else` statement executes a block of code when the condition inside the `if` statement is `false`. The `else` statement is always the last condition.

~~~
boolean condition1 = false;
if(condition1){
  System.out.println("condition1 is true");
}else{
  System.out.println("condition1 not true");
}
// Prints: condition1 is not true
~~~

<br>

### `else if Statements`
<br>

`else`-`if` statements can be chained together to check multiple conditions. Once a condition is `true`, a code block will be executed and the conditional statement will be exited.

There can be multiple `else`-`if` statements in a single conditional statement.

~~~
int testScore = 76;
char grade;

if(testScore >= 90){
  grade = 'A';
}else if(testScore >= 80){
  grade = 'B';
}else if(testScore >= 70){
  grade = 'C';
}else if(testScore >= 60){
  grade = 'D';
}else{
  grade = 'F';
}
System.out.println("Grade: " + grade); // Prints: C
~~~
<br>

### `if Statements`
<br>

An `if` statement executes a block of code when a specified boolean expression is evaluated as `true`.

~~~
if(true){
  System.out.println("This code executes");
}
// Prints: This code executes

if(false){
  System.out.println("This code does not execute");
}
// There is no output for the above statement
~~~

<br>

### `Nested Conditional Statements`
<br>

A nested conditional statement is a conditional statement nested inside of another conditional statement. The outer conditional statement is evaluated first; if the condition is `true`, the the nested conditional statement will be evaluated.

~~~
boolean studied = true;
boolean wellRested = true;

if(wellRested){
  Syste.out.println("Best of luck today!");
  if(studied){
    System.out.println("You are prepared for your exam!");
  }else{
    System.out.println("Study before your exam!");
  }
}

// Prints: Best of luck today!
// Prints: You are prepared for your exam!
~~~
<br>

### `AND Operator`
<br>

The AND logical operator is represented by `&&`. This operator returns `true` if the `boolean` expressions on both sides of the operator are `true`; otherwise, it returns `false`.

~~~
System.out.println(true && true);   // Prints: true
System.out.println(true && false);  // Prints: false
System.out.println(false && true);  // Prints: false
System.out.println(false && false); // Prints: false
~~~

<br>

### `NOT Operator`
<br>

The NOT logical operator is represented by `!`. This operator negates the value of boolean expression.

~~~
boolean a  = true;
System.out.println(!a); // Prints: false
System.out.println(!false); // Prints: true
~~~
<br>

### `The OR Operator`
<br>

The logical OR operator is represented by `||`. This operator will return `true` if at least one of the `boolean` expressions being compared has a `true` value; otherwise, it will return `false`.


~~~
System.out.println(true || true);     // Prints: true
System.out.println(true || false);    // Prints: true
System.out.println(false || true);    // Prints: true
System.out.println(false || false);   // Prints: false
~~~
<br>

### `Conditional Operators - Order of Evaluation`
<br>

If an expression contains multiple conditional operators, the order of evaluation is as fallows: `Expression in parenthesis` -> `NOT` -> `AND` -> `OR`.

~~~
boolean foo = true && (!false || true); // true

/*
(!false || true) is evaluated first because it is contained within parentheses.

Then !false is evaluated as true because it uses the NOT operator.

Next, (true || true) is evaluation as true.

Finally, true && true is evaluated as true meaning foo is true.
*/
~~~

<br>
<hr>
<br>

## Topic 5: Arrays and ArraysLists
<br>

### `Index`

An index refers to an element's position within an array.

The index of an array starts from 0 and goes up to one less than the total length of the array.

~~~
int[] marks = { 50, 55, 60, 70, 80};

System.out.println(marks[0]);
// Output: 50

System.out.println(marks[4]);
// Output: 80
~~~
<br>

###  `Arrays`

In Java, ana rray is used to store a list of elements of the same datatype.

Arrays are fixed in size and their elements are ordered.

~~~
// Create an array of 5 int elements
int[] marks = { 10, 20, 30, 40 ,50}; 
~~~
<br>

###  `Array creation in Java`
<br>

In Java, an array can be created in the following ways:

- Using the `{}` notation, by adding each element all at once.
- Using the `new` keyword, and assigning each position of the array individually.

~~~
int[] age = { 20, 21, 30};

int[] marks = new int[3];
marks[0] = 50;
marks[1] = 70;
marks[2] = 93;
~~~
<br>

### `Changing an Element Value`
<br>

To change an element value, select the element via its index and use the assignment operator to set a new value.

~~~
int[] nums = { 1, 2, 0, 4};
// Change value at index 2
nums[2] = 3; 
~~~
<br>

### `Java ArrayList`
<br>

In Java, an `ArrayList` is used to represent a dynamic list.

While Java arrays are fixed in size (the size cannot be modified), an `ArrayList` allows flexibility by being able to both add and remove elements.

~~~ 
// import the Arralist package
import java.util.ArrayList;

// creata an ArrayList called students
ArrayList<String> students = new ArrayList<String>();
~~~ 
<br>

### `Modifying ArrayLists in Java`
<br>

An `ArrayList` can easily be modified using built in methods.

To add elements to an `ArrayList`, you use the `add()` method. The element that you want to add goes inside of the `()`.

To remove elements from an `ArrayList`, you use the `remove()` method. Inside the `()` you can specify the index of the element that you want to remove. Alternatively, you can specify directly the element that you want to remove.

~~~
import java.util.ArrayList;

public class Students{
  public static void main(String[] args){

    // create an ArrayList called studentList, which initially holds []
    ArrayList<String> studentList = new ArrayList<String>();

    // add students to the ArrayList
    studentList.add("John");
    studentList.add("Lilly");
    studentList.add("Samantha";
    studentList.add("Tony");

    // remove John from the ArrayList, the Lilly
    studentList.remove(0);
    studentList.remove("Lilly");

    // studentList now holds [Samantha, Tony]

    System.out.println(studentList);
  }
}
~~~


<br>
<hr>
<br>

## Topic 6: Loops
<br>

### `For-each statement in Java`
<br>

In Java, the `for-each` statement allows you to directly loop through each item in an array or `ArrayList` and perform some action with each item.

When creating a `for-each` statement, you must include the `for` keyword and two expression inside of parentheses, separated by a colon. These include:

1) The handle for an element we're currently iterating over.
2) The source array or `ArrayList` we're iterating over.

~~~
// array of numbers
int[] numbers = { 1, 2, 3, 4, 5};

// for-each loop that prints each number in numbers
for(int num : numbers){
  System.out.println(num);
}
// int num is the handle while numbers is the source array.
~~~

<br>
<hr>
<br>

## Topic 7: String Methods
<br>

### `length() String Method in Java`
<br>

In Java, the `length()` method returns the total number of characters - the length - of a `String`.

~~~
String str = "Codeacademy";

Sytem.out.println(str.length());
// Prints: 10
~~~
<br>

### `concat() String Method in Java`
<br>

In Java, the `concat()` string method is used to append one `String` to the end of another `String`. This method returns a `String` representing the text of the combined strings.

~~~ 
String s1 = "Hello";
String s2 = " World!";

String s3 = s1.concat(s2);
// concatenates string s1 and s2

System.out.println(s3);
// Prints: "Hello World!"
~~~ 
<br>

### `String Method equals() in Java`
<br>

In Java, the `equals()` string method tests for equality between two `String`s.

`equals()` compares the contents of each `String`. If all of the characters between the two match, the method returns `true`. If any of the characters do not match, it returns `false`.

Additionally, if you want to compare two strings without considering upper/lower cases, you can use `.equalsIgnoreCase()`.

~~~
String s1 = "Hello";
String s2 = "World";

System.out.println(s1.equals("Hello"));
// Prints: true

Syste.out.println(s2.equals("Hello"));
// Prints: false

System.out.println(s1.equalsIgnoreCase("world"));
// Prints: true
~~~
<br>

### `indexOf() String Method in Java`
<br>

In Java, the `indexOf()` string method returns the first occurance of a character or a substring in a `String`. The character/substring that you want to find the index of goes inside of the `()`.

If `indexOf()` cannot find the character or substring, it will return -1.

~~~ 
String str = "Hello World!";

System.out.println(str.indexOf("l"));
// Prints: 2

System.out.println(str.indexOf("Wor"));
// Prints 6

System.out.println(str.indexOf("z"));
// Prints: -1
~~~ 
<br>

### `charAt() String Method in Java`
<br>

In Java, the `charAt()` string method returns the character of a `String` at a specified index. The index value is passed inside of `()`, and should lie between 0 and `length()-1`.

~~~
String str = "This is a string";

System.out.println(str.charAt(0));
// Prints: 'T'

System.out.println(str.charAt(15));
// Prints: 'g'
~~~
<br>

### `toUpperCase() and toLowerCase() String Methods`
<br>

In Java, we can easily convert a `String` to upper or lower case with the help of a few string methods:

- `toUpperCase()` returns the string value converted to uppercase.
- `toLowerCase()` returns the string value converted to lowercase.

~~~
String str = "Hello World!";

String uppercase = str.toUpperCase();
// uppsercase = "HELLO WORLD!"

String lowercase = str.toLowerCase();
// lowercase = "hello world!"
~~~

<br>
<hr>
<br>

## Topic 8: Access, Encapsulation, and Static Methods
<br>

### `The public and private keywords`
<br>

In Java, the keywords `public` and `private` define the access of classes, instance variables, constructors, and methods.

`private` restricts access to only the class that declared the structure, while `public` allows for access from any class.
<br>

### `Encapsulation`
<br>

Encapsulation is a technique used to keep implementation details hidden from other classes. Its aim is to create small bundles of logic.
<br>

### `The private keyword`
<br>

In Java, instance variables are encapsulated by using the `private` keyword. This prevents other classes from directly accessing these variables.

~~~ 
public class CheckingAccount{
  // Three private instance variables
  private String name;
  private int balance;
  private String id;
}
~~~ 
<br>

### `Accessor Methods`
<br>

In Java, accessor methods return the value of a `private` variable. This gives other classes access to that value stored in that variable, without having direct access to the variable itself.

Accessor methods take no parameters and have a return type that matches the type of the variable they are accessing.

~~~
public class CheckingAccount{
  private int balance;

  // An accessor method
  public int getBalance(){
    return this.balance;
  }
}
~~~
<br>

### `Mutator Methods`
<br>

In Java, mutator methods reset the value of a `private` variable. This give other classes the ability to modify the value stored in that variable without having direct access to the variable itself.

Mutato methods take one parameter whose type matches the type of the variable it is modifying. Mutator methods usually don't return anything.

~~~
public class checkingAccount{
  private int balance;

  // A mutator method
  public void setBalance(int newBalance){
    this.balance = newBalance;
  }
}
~~~
<br>

### `Local Variables`
<br>

In Java, local variables can only be used within the scope that they were defined in. This scope is often defined by a set of curly brackets. Variables can't be used outside of those brackets.

~~~
public void exampleMethod(int exampleVariable){
  // exampleVariable can only be used inside these curly brackets.
} 
~~~
<br>

### `The this Keyword with Variables`
<br>

In Java, the `this` keyword can be used to designate the difference between instance variables and local variables. Variables with `this` reference an instance variable.

~~~
public class Dog{
  public String name;

  public void speak(String name){
    // Prints the instance variable named name
    System.out.println(this.name);

    // Prints the local variable named name
    System.out.println(name);
  }
}
~~~
<br>

### `The this Keyword with Methods`
<br>

In Java, the `this` keyword can be used to call methods when writing classes.

~~~
public class ExampleClass{
  public void exampleMethodOne(){
    System.out.println("Hello");
  }

  public void exampleMethodTwo(){
    // Calling a method using this
    this.exampleMethodOne();
    System.out.println("There");
  }
}
~~~
<br>

### `Static Methods`
<br>

Static methods are methods that can be called within a program without creating an object of the class.

~~~
// static method
public static int getTotal(int a, int b){
  return a + b;
} 

public static void main(String[] args){
  int x = 3;
  int y = 2;

  System.out.println(getTotal(x,y)); // Prints: 5
}
~~~
<br>

### `Calling a Static Method`
<br>

Static methods can be called by appending the dot operator to a class name followed by the name of the method.

~~~
int largerNumber = Math.max(3, 10); // CAll static method
System.out.println(largerNumber); // Prints: 10  
~~~
<br>


### `The Math Class`
<br>

The `Math` class (which is part of the java.lang package) contains a variety of static methods that can be used to perform numerical calculations.

~~~
System.out.println(Math.abs(-7.0)); // Prints: 7

System.out.println(MAth.pow(5,3)); // Prints: 125.0

System.out.println(Math.sqrt(52)); // Prints:7.211102550927978
~~~
<br>


### `The static Keyword`
<br>

Static methods and variables are declared as static by using the `static` keyword upon declaration.

~~~
public class ATM{
  // Static variables
  public static int totalMoney = 0;
  public static int numATS = 0;

  // A static Method
  public static void averageMoney(){
    System.out.println(totalMoney / numATS);
  }
} 
~~~
<br>

### `Static Methods and Variables`
<br>

Static methods and variables are associated with the class as a whole, not objects of the class. Both are used by using the name of the class followed by the `.` operator.

~~~ 
public class ATM{
  // Static variables
  public static int totalMoney = 0;
  public static int numATMs = 0;

  // A static method
  public static void averageMoney(){
    System.out.println(totalMoney / numATS);
  }

  public static void main(String[] args){

    // Accessing a static variable
    System.out.println("Total number of ATMs: " + ATM.numATMs);

    // Calling a static method
    ATM.averageMoney();
  }
}
~~~ 
<br>


### `Static Methods with Instance Variables`
<br>

Static methods cannot access or change the values of instance variables.

~~~ 
class ATM{
  // Static Variables
  public static int totalMoney = 0;
  public static int numATMs = 0;

  public int money = 1;

  // A static method
  public static void averageMoney(){
    // Can not use this.money here because a static method can't access instance variables
  }
}
~~~
<br>


### `Methods with Static Variables`
<br>

Both non-static and static methods can access or change the values of static variables.

~~~
class ATM{
  // Static method
  public static int totalMoney = 0;
  public static int numATMs = 0;
  public int money = 1;

  // A static method interacting with a static variable
  public static void staticMethod(){
    totalMoney += 1;
  }
  
  // A non-static method interacting with a static variable
  public void nonStaticMethod(){
    totalMoney += 1;
  }
}
~~~

<br>


### `Static Methods and the this Keyword`
<br>

Static methods do not have a `this` reference and are therefore unable to use the class's instance variables or call non-static methods.

~~~
public class DemoClass{
  public int demoVariable = 5;

  public void demoNonStaticMethod(){

  }
  public static void demoStaticMethod(){
    // Can't use "this.demoVariable" or "this.demoNonStaticMethod()"
  }
}
~~~

<br>
<hr>
<br>

## Topic 9: Inheritance and Polymorphism
<br>

### `Inheritance in Java`
<br>

`Inheritance` is an important feature of object-oriented programming in Java. It allows for one class (`child class`) to inherit the fields and methods of another class (`parent class`). For instance, we might want a child class `Dog` to inherent traits from a more general parent class `Animal`.

When defining a child class in Java, we use the keyword `extends` to inherit from a parent class.

~~~ 
// Parent class
class Animal{
  // Animal class members
}

// child class
class Dog extends Animal{
  // Dog inherits traits from Animal

  // Additional Dog class members
}
~~~
<br>


### `Main() method in Java`
<br>

In simple Java programs, you may work with just one class and one file. However, as your programs become more complex you will work with multiple classes, each of which requires its own file. Only one of these files in the Java package requires a `main()` method, and this is the file that will be run in the package.

For example, say we have two files in our Java package for two different classes:

- `Shape`, the parent class.
- `Square`, the child class.

If the Java file containing our `Shape` class is the only one with a `main()` method, this is the file that will be run for our Java package.

~~~
// shape,java file
class Shape{
  public static void main(String[] args){
    Square s1 = new Square();
  }
} 

// Square.java file
class Square extends Shape{

}
~~~

<br>

### `super() in Java`
<br>

In Java, a child class inherits its parent's fields and methods, meaning it also inherits the parent's constructor. Sometimes, we may want to modify the constructor, in which case we can use the `super()` method, which acts like the parent constructor inside the child class constructor.

Alternatively, we can also completely override a parent class constructor by writing a new constructor for the child class.

~~~
// Parent class
class Animal{
  String sound;
  Animal(String snd){
    this.sound = snd;
  }
} 

// child class
class Dog extends Animal{
  // super() method can act like the parent constructor inside the child class constructor.
  Dog(){
    super("woof");
  }

  // alternatively, we can override the cosntructor completely by defining a new constructor
  Dog(){
    this.sound = "woof";
  }
}
~~~
<br>

### `Protected and Final keywords in Java`
<br>


When creating classes in Java, sometimes we may want to control child class access to parent class members. We can use the `protected` and `final` keywords to do just that.

`protected` keeps a parent class member accessible to its child classes, to files within its own package, and by subclasses of this class in another package.

Adding `final` before a parent class method's access modifier makes it so that any child classes cannot modify that method - it is immutable.

~~~
class Student{

  protected double gpa;
  // any child class od Student can access gpa

  final protected boolean isStudent{
    return true;
  }
  // any child class of Student cannot modify isStudent()
} 
~~~
<br>


### `Polymorphism in Java`
<br>

Java incorporates the object-oriented programming principle of `polymorphism`.

Polymorphism allows a child class to share the information and behavior of its parent class while also incorporating its own functionality. This allows for the benefits of simplified syntax and reduced cognitive overload for developers.

~~~
// Parent class
class Animal{
  public void greeting(){
    System.out.println("The animal greets you.");
  }
} 

// Child class
class Cat extends Animal{
  public void greeting(){
    System.out.println("the cat meows.");
  }
}

class MainClass{
  public static void main(String[] args){
    Animal a1 = new Animal(); // animal object 
    Animal c1 = new Cat(); // Cat object

    a1.greeting(); // Prints: The animal greets you.
    c1.greeting(); // Prints: The cat meows.
  }
}
~~~
<br>


### `Method Overriding in Java`
<br>

In Java, we can easily `override` parent class methods in a child class. Overriding a method is useful when we want our child class method to have the same name as a parent class method but behave a bit differently.

In order to override a parent class method in a child class, we need to make sure that the child class method has the following in common with its parent class method:

- Method name
- Return type
- NUmber and type of parameters

Additionally, we should include the `@Override` keyword above our child class method to indicate to the compiler that we want to override a method in the parent class.

~~~
// Parent class
class Animal{
  public void eating(){
    System.out.println("The animal is eating!");
  }
} 

// Child class
class Dog extends Animal{
  // Dog's eating method overrides Animal's eating method

  @Override
  public void eating(){
    System.out.println("the dog is eating.");
  }
}
~~~
<br>


### `Child Classes in Arrays and ArrayLists`
<br>


In Java, polymorphism allows us to put instances of different classes that share a parent class together in an array of `ArrayList`.

For example, if we have an `Animal` parent class with child classes `Cat`, `Dog`, and `Pig` we can set up an array with instances of each animal and the iterate through the list of animals to perform the same action on each.

~~~ 
// Animal parent class with child classes Cat, Dog, and Pig.

Animal cat1, dog1, pig1;

cat1 = new Cat();
dog1 = new Dog();
pip1 = new Pig(); 

// Set up an array with instances of each animal

Animal[] animals = { cat1, dog1, pig1};

// Iterate through the list of animals and perform the same action with each
for(Animal animal : animals){
  animal.sound();
}
~~~ 

<br>
<hr>
<br>

## Topic 10: Debugging
<br>

<br>
<hr>
<br>

## Topic 11: Two-Dimensional Arrays
<br>

### `Nested Iteration Statements`
<br>
<br>

### `Declaring 2D Arrays`
<br>
<br>

### `Accessing 2D Array Elements`
<br>
<br>

### `Initializer List`
<br>
<br>

### `Modify 2D Array Elements`
<br>

### `Row-Major Order`
<br>
<br>

### `Column-Major Order`
<br>
<br>

### `Traversing With Enhanced For Loops`
<br>
<br>




<br>
<hr>
<br>













































































































































